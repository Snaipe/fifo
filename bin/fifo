#!/usr/bin/env ruby

require "date"
require "cinch"
require "sinatra"
require "yaml"
require "json"
require "unicode_utils/upcase"
require "monads/optional"
require "monads/many"

include Monads

config_file = ARGV.shift || "config.yml"
if not File.exists? config_file
  puts "Can't find config file #{config_file}"
  puts "Either create it or specify another config file with: #{File.basename $0} [filename]"
  exit
end

$config = YAML.load_file config_file

include Cinch::Helpers

class Quoi
  include Cinch::Plugin

  set :prefix, ''
  match /\s*quoi[?!]*\s*/i
  def execute(m)
    m.reply("ffeur")
  end
end

class Puns
  include Cinch::Plugin

  set :prefix, ''
  match /^(.*\s)?(cri|kri|dit |di)([[:alpha:]]+).*/i

  def execute(m, unused, prefix, trail)
    if prefix and trail
      if prefix.match /^(cri|kri)$/i
        msg = UnicodeUtils.upcase(trail) + '!'
      else
        msg = trail
      end
      m.reply(msg)
    end
  end
end

class GTFO
  include Cinch::Plugin

  set :prefix, /^fifo:/i
  match /.*(ta gueule|la ferme|fuck you|connard|encul|foutre).*/i

  def execute(m, match)
    ["Dear #{m.user},", " ",
     "kindly go fuck yourself.", " ",
     "Sincerely,", " ",
     "-- ", "fifo"].each do |msg|
      m.reply(msg)
    end
  end
end

$bot = Cinch::Bot.new do
  configure do |c|
    c.nick = $config["irc"]["nick"]
    c.user = "fifo"
    c.realname = "FIFO"
    c.password = $config["irc"]["password"]
    c.server = $config["irc"]["server"]
    c.port = $config["irc"]["port"]
    c.channels = $config["irc"]["channels"]
    c.plugins.plugins = [Puns, Quoi, GTFO]
  end
end

Thread.new do
  $bot.start
end

def channels_for_repo(repo)
  filters = Optional.new($config["filters"])

  Many.new($config["irc"]["channels"]).
    within { |chan| chan unless filters.include? chan and filters[chan].include? repo }.
    values
end

def say(chans,msg)
  chans.each do |chan|
    $bot.Channel(chan).send msg
  end
end

configure do
  set :bind, $config["http"]["host"]
  set :port, $config["http"]["port"]
  set :logging, false
  set :lock, true
end

get "/" do
  "Fifo lives here. Direct your hooks to /github/push."
end

def json_to_date(timestamp)
  begin
    DateTime.parse(timestamp)
  rescue ArgumentError
    Time.at(timestamp.to_i)
  end
end

post "/github/push" do
  request.body.rewind
  push = JSON.parse request.body.read

  repo = push["repository"]["full_name"]
  branch = push["ref"].gsub(/^refs\/heads\//,"")

  # sort commits by timestamp
  push["commits"].sort! do |a,b|
    (ta, tb) = [a, b].map { |e| json_to_date(e["timestamp"]) }
    tb <=> ta
  end

  chans = channels_for_repo repo

  nb_commits = push["commits"].length
  head = "%s: %s %spushed %s commit%s to %s <%s>" %
    [Format(:orange, repo),
     Format(:green, push["pusher"]["name"]),
     push["forced"] ? "(forcefully) " : "",
     Format(:orange, nb_commits.to_s), nb_commits == 1 ? '' : 's',
     Format(:blue, branch),
     Format(:red, push["compare"])]
  say chans, head

  # output first 3 commits
  push["commits"][0..2].each do |c|
    reply = " + [%s] %s: %s" %
      [Format(:red, c["id"][0..6]),
       Format(:green, c["author"]["name"]),
       Format(:orange, c["message"])]
    say chans, reply
  end

  if nb_commits > 2
    say chans, " ... and #{nb_commits - 3} more"
  end

  ""
end
